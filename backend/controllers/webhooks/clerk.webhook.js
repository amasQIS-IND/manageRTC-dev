/**
 * Clerk Webhook Controller
 * Handles Clerk webhook events for user creation, updates, and deletion
 * Automatically creates employee records when users sign up through Clerk
 */

import { clerkClient } from '@clerk/clerk-sdk-node';
import { getTenantCollections } from '../../config/db.js';
import { asyncHandler } from '../../middleware/errorHandler.js';
import { sendSuccess, sendCreated } from '../../utils/apiResponse.js';

/**
 * Verify Clerk webhook signature
 */
function verifyWebhookSignature(req) {
  const signature = req.headers['x-clerk-signature'];
  const webhookSecret = process.env.CLERK_WEBHOOK_SECRET;

  if (!webhookSecret) {
    console.warn('[Clerk Webhook] No webhook secret configured, skipping verification');
    return true; // Allow in development
  }

  if (!signature) {
    return false;
  }

  // In production, verify the signature using Svix or Clerk's verification
  // For now, we'll skip verification in development
  return true;
}

/**
 * @desc    Handle Clerk webhook events
 * @route   POST /api/webhooks/clerk
 * @access  Public (webhook signature verification)
 */
export const handleClerkWebhook = asyncHandler(async (req, res) => {
  console.log('[Clerk Webhook] Received webhook event');

  // Verify webhook signature
  if (!verifyWebhookSignature(req)) {
    return res.status(401).json({ error: 'Invalid webhook signature' });
  }

  const { data, type } = req.body;

  console.log('[Clerk Webhook] Event type:', type);
  console.log('[Clerk Webhook] User ID:', data?.id);

  switch (type) {
    case 'user.created':
      await handleUserCreated(data);
      break;

    case 'user.updated':
      await handleUserUpdated(data);
      break;

    case 'user.deleted':
      await handleUserDeleted(data);
      break;

    default:
      console.log('[Clerk Webhook] Unhandled event type:', type);
  }

  return sendSuccess(res, { received: true }, 'Webhook processed successfully');
});

/**
 * Handle user.created event - Create employee record
 */
async function handleUserCreated(clerkUser) {
  console.log('[Clerk Webhook] Creating employee record for user:', clerkUser.id);

  try {
    // Get user's company and role from metadata
    const companyId = clerkUser.public_metadata?.companyId;
    const role = clerkUser.public_metadata?.role || 'employee';

    if (!companyId) {
      console.log('[Clerk Webhook] No companyId in metadata, skipping employee creation');
      return;
    }

    // Get tenant collections
    const collections = getTenantCollections(companyId);

    // Check if employee already exists
    const existingEmployee = await collections.employees.findOne({
      clerkUserId: clerkUser.id
    });

    if (existingEmployee) {
      console.log('[Clerk Webhook] Employee already exists for user:', clerkUser.id);
      return;
    }

    // Extract user data from Clerk
    const firstName = clerkUser.first_name || '';
    const lastName = clerkUser.last_name || '';
    const email = clerkUser.email_addresses?.[0]?.email_address || '';
    const username = clerkUser.username || email.split('@')[0];

    if (!email) {
      console.error('[Clerk Webhook] No email found for user:', clerkUser.id);
      return;
    }

    // Check if email already exists in employees
    const emailExists = await collections.employees.findOne({
      'contact.email': email
    });

    if (emailExists) {
      console.log('[Clerk Webhook] Email already exists in employees, linking to Clerk user');
      // Update existing employee with clerkUserId
      await collections.employees.updateOne(
        { _id: emailExists._id },
        { $set: { clerkUserId: clerkUser.id } }
      );
      return;
    }

    // Get department and designations (use first available as default)
    const departments = await collections.departments.find({}).limit(1).toArray();
    const designations = await collections.designations.find({}).limit(1).toArray();

    const departmentId = departments[0]?._id || null;
    const designationId = designations[0]?._id || null;

    // Create employee record
    const employeeToInsert = {
      clerkUserId: clerkUser.id,
      employeeId: null, // Will be auto-generated by pre-save hook
      firstName: firstName,
      lastName: lastName,
      fullName: `${firstName} ${lastName}`.trim(),
      email: email,
      phone: clerkUser.phone_numbers?.[0]?.phone_number || '',
      contact: {
        email: email,
        phone: clerkUser.phone_numbers?.[0]?.phone_number || ''
      },
      departmentId: departmentId?.toString() || null,
      designationId: designationId?.toString() || null,
      employmentType: 'Full-time',
      employmentStatus: 'Active',
      joiningDate: new Date(),
      workLocation: 'Remote',
      companyId: companyId,
      role: role,
      account: {
        userName: username,
        role: role.charAt(0).toUpperCase() + role.slice(1)
      },
      createdAt: new Date(),
      updatedAt: new Date(),
      status: 'Active',
      isActive: true,
      isDeleted: false
    };

    const result = await collections.employees.insertOne(employeeToInsert);

    if (result.insertedId) {
      console.log('[Clerk Webhook] Employee record created:', result.insertedId);
    } else {
      console.error('[Clerk Webhook] Failed to create employee record');
    }
  } catch (error) {
    console.error('[Clerk Webhook] Error creating employee record:', error);
    // Don't throw - we don't want to fail the webhook
  }
}

/**
 * Handle user.updated event - Update employee record
 */
async function handleUserUpdated(clerkUser) {
  console.log('[Clerk Webhook] Updating employee record for user:', clerkUser.id);

  try {
    const companyId = clerkUser.public_metadata?.companyId;

    if (!companyId) {
      return;
    }

    const collections = getTenantCollections(companyId);

    // Find employee by clerkUserId
    const employee = await collections.employees.findOne({
      clerkUserId: clerkUser.id
    });

    if (!employee) {
      console.log('[Clerk Webhook] Employee not found for user:', clerkUser.id);
      return;
    }

    // Update employee with latest data
    const updateData = {
      firstName: clerkUser.first_name || employee.firstName,
      lastName: clerkUser.last_name || employee.lastName,
      fullName: `${clerkUser.first_name || ''} ${clerkUser.last_name || ''}`.trim(),
      email: clerkUser.email_addresses?.[0]?.email_address || employee.email,
      phone: clerkUser.phone_numbers?.[0]?.phone_number || employee.phone,
      'contact.email': clerkUser.email_addresses?.[0]?.email_address || employee.email,
      'contact.phone': clerkUser.phone_numbers?.[0]?.phone_number || employee.phone,
      profileImage: clerkUser.image_url || employee.profileImage,
      role: clerkUser.public_metadata?.role || employee.role,
      updatedAt: new Date()
    };

    await collections.employees.updateOne(
      { _id: employee._id },
      { $set: updateData }
    );

    console.log('[Clerk Webhook] Employee record updated:', employee._id);
  } catch (error) {
    console.error('[Clerk Webhook] Error updating employee record:', error);
  }
}

/**
 * Handle user.deleted event - Soft delete employee record
 */
async function handleUserDeleted(clerkUser) {
  console.log('[Clerk Webhook] Soft deleting employee record for user:', clerkUser.id);

  try {
    // We need to find the employee across all companies
    // For now, we'll skip this as it requires searching across all collections
    console.log('[Clerk Webhook] User deletion handling not implemented');
  } catch (error) {
    console.error('[Clerk Webhook] Error deleting employee record:', error);
  }
}

export default {
  handleClerkWebhook
};
